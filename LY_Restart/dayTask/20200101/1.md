<!--
 * @Author: your name
 * @Date: 2020-01-01 22:13:53
 * @LastEditTime : 2020-01-04 00:32:39
 * @LastEditors  : Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \beixiang_ly\LY_Restart\dayTask\20200101\1.md
 -->
# 线程和进程的区别 【廖雪峰的多线程】。 java： https://www.liaoxuefeng.com/wiki/1252599548343744/1304521607217185
有一点我们应该都显而易见，我们现代的操作系统都可以执行多任务。多任务就是同时运行多个任务，例如我们可以边用QQ音乐听歌又可以用QQ边聊天。
但其实CPU执行代码都是一条一条顺序执行的。既然是顺序执行，那为什么即使是单核CPU，也是可以同时运行多个任务的？
这是因为操作系统执行多任务实际上就是让CPU对[多个任务轮流交替执行]！例如，让QQ音乐执行0.001s，又去让QQ执行0.001s。这种极短时间内的交替执行，就会造成同时执行多任务的假象。
主要注意的是，即使是多核CPU，因为通常任务的数量远远多于CPU的核数，所以任务也是交替执行的。

  * 了解一下[进程] & [线程]：
      在计算机中，我们把一个任务称为一个[进程]，浏览器就是一个进程，视频播放器是另一个进程，类似的，音乐播放器和word都是进程。
      某些进程内部还需要同时执行多个子任务，我们把这些子任务叫做[线程]。
      例如，我们在使用word时，word可以让我们一边打字，一边进行字数检查什么的，有时候你有需要先打印的文件，还可以后台进行文件打印。

      进程和线程的关系： 进程(1) -> 线程(n,n>=1);

      * 操作系统调度的最小任务单元其实不是进程，而是线程。
      常用的windows，Linux等操作系统都采用抢占式多任务，如何调度线程完全由操作系统决定，因为程序自己并不能决定什么时候执行，以及执行多长时间。

      * 因为同一个应用程序，即可以有多个进程，也可以有多个线程，因此，实现多任务的方法，有以下几种：
          - 多进程(多个进程，每个进程里面只有一个线程)：
              (process -> thread) * n
          - 多线程(一个进程里面有多个线程)：
              process -> thread * n
          - 多进程+多线程(多个进程，一个进程里面多个线程)：
              (process -> thread * n) * n

  * 进程 VS 线程 （多任务用哪个方式实现更好）
      进程和线程是包含关系，但是多任务既可以由多进程实现，可以由单进程内的多线程实现，还可以混合多进程+多线程。

      具体使用哪种，需要考虑到进程和线程的特点。

      和多线程相比，多进程的缺点在于：
        - 创建进程比创建线程开销大，尤其是在windows系统上。
        - 进程间的通信比线程间的通信要慢，因为线程间通信就是读写同一个变量，速度很快。
      
      而多进程的优点在于：
        - 多进程稳定性比多线程高，因为在多进程的情况下一个进程崩溃不会影响到其他进程，
        - 而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。

  * 多线程（java）
      java语言内置了多线程的支持： 一个java程序实际上是一个JVM进程，JVM进程用一个主线程来执行main()方法，在main()方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。

      因此，对于大多数java程序来说，我们说多任务，实际上是说如何使用多线程实现多任务。

      和单线程相比，多线程编程的特点在于： 
        - 多线程经常需要读写共享数据，并且需要同步。
        - 例如，播放电影时，就必须由一个线程播放视频，另一个线程播放音频，两个线程需要协调运行，否则画面和声音就不同步。因此，多线程编程的复杂度高，调试更加困难。
      
      java多线程编程的特点又在于：
        - 多线程模型 是java程序最基本的并发模型。
        - 后续 读写网络、数据库、Web开发等 都依赖java多线程模型。



  * 进程：
    - 首先了解一下：
      1. 我们都知道计算机的核心是[CPU]，它承担了所有的计算任务。
      2. [操作系统]是计算机的管理者，它负责任务的调度，资源的分配和管理，统领整个计算机硬件。
      3. [应用程序]是具有某种功能的程序，程序是运行于操作系统之上的。

    - 那么进程和它们有什么关系呢？：
      1. [进程]是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。
      2. [进程]是一种抽象的概念，从来没有统一的标准定义。[进程]一般由程序，数据集合和进程控制块三部分组成。
      3. 程序用于描述[进程]要完成的功能，是控制进程执行的指令集；数据集合是程序在执行时所需要的数据和工作区；程序控制块包含进程的描述信息和控制信息,是进程存在的唯一标志。

    - [进程]具有的特征：
      动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；
      并发性：任何进程都可以同其他进程一起并发执行；
      独立性：进程是系统进行资源分配和调度的一个独立单位；
      结构性：进程由程序，数据集合和进程控制块三部分组成

  * 线程： 
    在早期的操作系统中并没有线程的概念，进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位。
    任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。

    后来，随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。
    于是就发明了线程，线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。
    一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。
    一个标准的线程由线程ID，当前指令指针PC，寄存器和堆栈组成。
    而进程由内存空间(代码，数据，进程空间，打开的文件)和一个或多个线程组成。

  * 进程与线程的区别
    1. 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；
    2. 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线
    3. 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信号等)，某进程内的线程在其他进程不可见；
    4. 调度和切换：线程上下文切换比进程上下文切换要快得多

    总之，线程和进程都是一种抽象的概念，线程是一种比进程还小的抽象，线程和进程都可用于实现并发。在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位，它相当于一个进程里只有一个线程，进程本身就是线程。所以线程有时被称为轻量级进程后来，随着计算机的发展，对多个任务之间上下文切换的效率要求越来越高，就抽象出一个更小的概念-线程，一般一个进程会有多个(也可以是一个)线程。

  * 任务调度
    大部分操作系统的任务调度是采用时间片轮转的抢占式调度方式，也就是说一个任务执行一小段时间后强制暂停去执行下一个任务，每个任务轮流执行。任务执行的一小段时间叫做时间片，任务正在执行时的状态叫运行状态，任务执行一段时间后强制暂停去执行下一个任务，被暂停的任务就处于就绪状态，等待下一个属于它的时间片的到来。这样每个任务都能得到执行，由于CPU的执行效率非常高，时间片非常短，在各个任务之间快速地切换，给人的感觉就是多个任务在“同时进行”，这也就是我们所说的并发。

  * 为何不使用多进程而是使用多线程？
    1. 线程廉价，线程启动比较快，退出比较快，对系统资源的冲击也比较小。而且线程彼此分享了大部分核心对象(File Handle)的拥有权
    2. 如果使用多重进程，创建开销不可预期，且测试困难。

# 进程与线程【阮一峰+其他】  http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html
进程和线程是操作系统的基本概念，比较抽象。所以在查阅一番资料之后，将这些较为抽象的概念具象化：
  * CPU：计算机的核心，他承担了所有的计算任务。假设其为 一座工厂，时刻在生产。

  * 单个CPU一次只能运行一个任务：意味着工厂的电力是有限的，一次只能供给一个车间。也就是说，当一个车间在工作的时候，其他车间都必须停工。

  * 进程：进程就像是这些车间，代表CPU所能处理的单个任务。任何时候，CPU总是运行一个进程，其他进程处于非运行状态。

  * 线程：在一个车间里面，会有1个/n个工人，他们协同完成一个任务。线程就像是车间的工人，一个进程可以有多个线程，最少一个线程。

  * 进程的内存空间是共享的，每个线程都可以使用：车间的空间是工人们共享的，比如厕所，餐厅等每个工人都可以进出的。

  * 对于只能容纳 一个线程 使用的某些共享内存，一个线程使用时，其他线程必须等它结束，才能使用这一块内存：因为每间房间的大小不同，有的房间最多只能容纳一个人，比如厕所，所以里面的有人的时候，其他的人就不能进去了。

  * 为了让线程自觉等待，引入"互斥锁"（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域：当你不知道厕所有没有人使用的时候，最直接的办法就是进去看看，但是如果有人多尴尬啊，所以一个防止他人进入的简单办法就是门口加一把锁，先到的人先使用并上锁，后面的人看到上锁就知道有人在使用，自觉等待锁打开再进去。

  * 对于可以容纳n个线程使用的某些共享内存，n个线程使用时，其他线程必须排队等待：比如试衣间，只能允许n个固定人数试衣服，其他人必须等他们出来才能再进去。
  
  * 怎么判断该共享内存时候有n个线程在使用呢？：这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做"信号量"（Semaphore），用来保证多个线程不会互相冲突。
  
  总结： 难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者（n）。但是，因为mutex较为简单，且效率高，所以在必须保证【资源独占】的情况下，还是采用这种设计。

操作系统的设计，因此可以归纳为三点：
  1. 以多进程形式，允许多个任务同时进行。
  2. 以多线程形式，允许单个任务分成不同的部分运行。
  3. 提供协调机制，一方面防止进程之间和线程之间产生冲突，另一个方面允许进程和线程之间共享资源。


# 阮一峰的进程线程 纠错 补缺 http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html 
  * viho_he: 
    抛开各种技术细节，从应用程序角度讲：

    1、在单核计算机里，有一个资源是无法被多个程序并行使用的：cpu。

    没有操作系统的情况下，一个程序一直独占着全都cpu。

    如果要有两个任务来共享同一个CPU，程序员就需要仔细地为程序安排好运行计划--某时刻cpu由程序A来独享，下一时刻cpu由程序B来独享

    而这种安排计划后来成为OS的核心组件，被单独名命为“scheduler”，即“调度器”，它关心的只是怎样把单个cpu的运行拆分成一段一段的“运行片”，轮流分给不同的程序去使用，而在宏观上，因为分配切换的速度极快，就制造出多程序并行在一个cpu上的假象。

    2、在单核计算机里，有一个资源可以被多个程序共用，然而会引出麻烦：内存。

    在一个只有调度器，没有内存管理组件的操作系统上，程序员需要手工为每个程序安排运行的空间 -- 程序A使用物理地址0x00-0xff,程序B使用物理地址0x100-0x1ff，等等。

    然而这样做有个很大的问题：每个程序都要协调商量好怎样使用同一个内存上的不同空间，软件系统和硬件系统千差万别，使这种定制的方案没有可行性。
    为了解决这个麻烦，计算机系统引入了“虚拟地址”的概念，从三方面入手来做：
      2.1、硬件上，CPU增加了一个专门的模块叫MMU，负责转换虚拟地址和物理地址。
      2.2、操作系统上，操作系统增加了另一个核心组件：memory management，即内存管理模块，它管理物理内存、虚拟内存相关的一系列事务。
      2.3、应用程序上，发明了一个叫做【进程】的模型，（注意）每个进程都用【完全一样的】虚拟地址空间，然而经由操作系统和硬件MMU协作，映射到不同的物理地址空间上。不同的【进程】，都有各自独立的物理内存空间，不用一些特殊手段，是无法访问别的进程的物理内存的。

    3、现在，不同的应用程序，可以不关心底层的物理内存分配，也不关心CPU的协调共享了。然而还有一个问题存在：有一些程序，想要共享CPU，【并且还要共享同样的物理内存】，这时候，一个叫【线程】的模型就出现了，它们被包裹在进程里面，在调度器的管理下共享CPU，拥有同样的虚拟地址空间，同时也共享同一个物理地址空间，然而，它们无法越过包裹自己的进程，去访问别一个进程的物理地址空间。

    4、进程之间怎样共享同一个物理地址空间呢？不同的系统方法各异，符合posix规范的操作系统都提供了一个接口，叫mmap，可以把一个物理地址空间映射到不同的进程中，由不同的进程来共享。

    5、PS：在有的操作系统里，进程不是调度单位（即不能被调度器使用），线程是最基本的调度单位，调度器只调度线程，不调度进程，比如VxWorks

    进程是OS在程序运行时资源分配和调度的一个独立单元，一个进程可以开启一个或多个线程，进程抢到cpu时间片之后，如果该进程开启了多个线程，再由线程抢占cpu时间片，谁得到时间片谁执行。

    就我所知道到的OS(windows / linux / VxWorks / qnx)里，目前没有哪个是这样做的。
    虽然目前没有不排除有这系统会这样去实现，然而从模型来说，这是个很糟糕的模型，因为这个模型增加了调度器的复杂度，调度器需要判断当前调度的单位是进程还是线程，并且做出不同的处理，加上优先级、时间片轮转、线程/进程运行状态等机制以后，此模型复杂度会显著增加，而到了SMP（同构并发多处理器）的系统上，此模型基本上已无能够工作的可能性。

    即使在qnx这样鼓励用进程而非线程的微内核的OS上，文档仍然说到：Threads are scheduled globally across all processes.即调度的基本单位是线程，不是进程。调度器在调度任务时，只知道线程，不知道进程这个东西，对于进程的管理，是OS别的组件的事情。

  * viho_he: 推荐资料
    操作系统是一门实践性极强的学问，而且与CPU的硬件功能结合得非常紧密，可以说操作系统的核心模块都是关于怎样玩转CPU的硬件功能的，很多过去原本是操作系统的软件功能，被做到了CPU硬件里面。个人经验是，不要怕接触技术细节，只有在大量具体的技术细节的积累之上，才能真正理解抽像的概念。 我建议你调试linux kernel玩玩，有条件的话买一个arm的开发板自己弄弄，没条件可以在PC机上安装模拟器来玩，比如QEMU。 读书的话，可以啃《Linux内核源代码情景分析》，不用读全书，只把你关心的那几章通读就行了。 另外，为了能真正读懂kernel源码，你需要至少学习一门CPU的知识（即阅读枯燥冗长的CPU手册）作为辅助，可以从IA入手，也可以从ARM入手，以你手头的能用的硬件为准。最起码要了解中断的处理机制、内存的处理机制。 《Linux内核源代码情景分析》用的是IA。

  * herodot:
    阮兄，
    我是你的博客（包括你的英文BLOG）的忠实读者。这个回复纯属技术探讨。

    你这篇关于进程和线程的文章，图文并茂，很通俗，但不易懂。坦白说，在我看来很多比喻很不恰当，比如：
    1. 车间/电力/人三者，来比喻进程/CPU/线程三者，其实既没有体现出进程作为程序的一次执行（有独立的内存空间）这一特点，也没有体现出线程作为CPU调度单位这一特点。人和电力的关系是什么呢？所以“车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的”，这句话就很难理解。
    2. 用厕所容量，来比喻锁，也不合适。因为线程间同步是为了防止竞争（就是说因同时修改，而导致的数据不一致）。本质上讲，[进程的内存空间是天然独立的，线程的内存空间是天然共享的。]正因为如此，进程通信/线程同步才是系统编程的很大一块内容。

    进程和线程简单而基本靠谱的定义如下：
    1. 进程：程序的一次执行
    2. 线程：CPU的基本调度单位
    这两个概念虽然过于简单，但是完全可以为理解OS/线程/进程打下坚实的基础，我认为关于进程/线程的探讨，无论采用何种方式，都必须以这两句话为落脚点，才算靠谱。

    你写的大多数文章相当出色。在以通俗的方式解释复杂的概念这方面，尤其出色。但是，我个人的经验，这种方式比较适合用来解释一个复杂概念的一个方面，或者从某个角度的理解。想面面俱到的说明白一个复杂的系统，繁琐枯燥的概念，以及这些概念间的推演几乎不可避免。坦白说，在实际项目中大量用到线程/进程之前，我看过很多遍相关的概念，也写过小的示例程序，但真到了用的时候，还是发现之前没搞明白。我对进程/线程的理解也很粗浅。个人见解，仅供参考。
 
  * 阮一峰回复：
      我完全同意你对进程和线程的定义。

      这篇文章的比喻，确实不是完全准确。但是，进程和线程要找到现实生活中准确的对应，恐怕很困难吧。

      我的基本想法是：

      （1）进程是一个容器。
      （2）线程是容器中的工作单位。

      车间—工人的比喻就是这样来的。



# 进程与线程等抽象概念类比: https://baijiahao.baidu.com/s?id=1611925141861592999&wfr=spider&for=pc

  1. 单核CPU:一台单核处理器计算机=-个车间;

  2. 多核CPU:一台多核处理器计算机=一座工厂;

  * 1个cpu里面有几核？ 一般cpu 4核8g, 8核16g.
      * cpu单核和多核的区别为：单元组数不同、运行线程数不同、执行速度不同。
        一、单元组数不同

          1、cpu单核：cpu单核只有1个独立的CPU核心单元组。

          2、cpu多核：cpu多核包括2个相对独立的CPU核心单元组。

        二、运行线程数不同

          1、cpu单核：cpu单核能同时运行的线程数较多核更少，不利于同时运行多个程序。死机卡顿。

          2、cpu多核：cpu多核能同时运行的线程数较单核更多，有利于同时运行多个程序。

  3. 进程:一个车间=-一个进程; (即-程序的一次执行)

  4. 多进程:一座工厂可以同时运行多个车间; 

  5. CPU和进程: 单核CPU只能同时运行单个进程，多核CPU可以同时运行多个进程。

  6. 线程:车间内一个工人 = 一个线程; 

  7. 进程与线程: -一个进程可以包括多个线程。

  8. 线程间内存共享: 车间的空间是工人们共享的。因为进程（车间）的内存空间是天然独立的，但是线程（工人）的内存空间是天然共享的，一个进程有多个线程。（看图 进程与线程.jpg）
  ps: https://baijiahao.baidu.com/s?id=1611925141861592999&wfr=spider&for=pc 该文有提到： 线程没有地址空间，线程包含在进程的地址空间中。进程拥有的所有资源都属于线程，所有的线程共享进程的内存和资源。同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。但是每个线程拥有自己的栈段， 寄存器的内容，栈段又叫运行时段，用来存放所有局部变量和临时变量。
  所以我是这样理解的,上文提及的进程的内存空间是天然独立的是针对多进程的时候，不同进程与进程之间是相对独立，无法访问的，及A车间与B车间之间是相互独立的。这样的话A车间的所有内存和资源，A车间的工人都可以共享。也就是下面这些：
    - 进程的内存空间是共享的，每个线程都可以使用这些共享内存。
    - 内存安全: 可是，每个车间容纳大小不同，有的最多只能容纳一个人。车间人满的时候，其他人就进不去了。
    - 个线程使用某些共享内存时，其他线程必须等它结束，才能使用这-块内存。
    - 互斥锁:一个防止他人进入的简单方法，就是门口加一-把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。
    这就叫“互斥锁"-Mutex，防止两个线程同时读写某-块内存区域。
    - 信号量:这时的解决方法，就是在门口挂n把钥匙。进去的人就取-把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知 道必须在门口排队等着了。
    这种做法叫做"信号量”(Semaphore) ，用来保证多个线程不会互相冲突。
    - 锁和信号量:不难看出，互斥锁是信号量的一种特殊情况(n=1时) 。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。

  * 多进程和多线程的区别在于：
    1. 在CPU看来，所有的任务都是一个一个轮流执行的，一个任务可以被CPU执行，说明它所申请的除了CPU以外的所有资源，都已经获得。这里除了CPU以外的所有资源构成程序的执行环境，也称为程序的上下文。
    2. 一个进程的处理过程是：加载上下文—> CPU执行 —> 保存上下文
    3. 进程的切换，也是同样的处理过程，每次都要加载上下文和保存上下文。这样每次的调入、调出，对系统来说，是会造成一定的开销的。于是就引入了“线程”。
    4. 线程的切换: 一个进程可以分为一个或多个线程，这些线程共享一样的上下文，也就是说，属于同一个进程的线程之间的切换，就少了 加载/保存上下文，开销减少，效率就提高了。
    5. 进程是资源分配的最小单位，在没有引入线程以前，进程既是最小资源分配单位，也是最小调度单位。后来引入了线程，最小调度单位就是线程，资源分配和调度分开了，目的是为了更好的利用CPU。

# CPU 调度的基本单位 https://zhidao.baidu.com/question/1175258965571450659.html
  * 在CPU看来，所有的任务都是一个一个轮流执行的，一个任务可以被CPU执行，说明它所申请的除了CPU以外的所有资源，都已经获得。这里除了CPU以外的所有资源构成程序的执行环境，也称为程序的上下文。
  一个进程的处理过程是：加载上下文—> CPU执行 —> 保存上下文
  进程的切换，也是同样的处理过程，每次都要加载上下文和保存上下文。这样每次的调入、调出，对系统来说，是会造成一定的开销的。于是就引入了“线程”。
  线程的概念: 一个进程可以分为一个或多个线程，这些线程共享一样的上下文，也就是说，属于同一个进程的线程之间的切换，就少了 加载/保存上下文，开销减少，效率就提高了。
  进程是资源分配的最小单位，在没有引入线程以前，进程既是最小资源分配单位，也是最小调度单位。后来引入了线程，最小调度单位就是线程，资源分配和调度分开了，目的是为了更好的利用CPU。

  * CPU调度的基本单位是是线程。
    - 线程是操作系统能够进行运算调度的最小单位。
    一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。
    - 图 线程状态.jpg
    - 扩展资料
      通常在一个进程中可以包含若干个线程，它们可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统内多个程序间并发执行的程度。
      当下推出的通用操作系统都引入了线程，以便进一步提高系统的并发性，并把它视为现代操作系统的一个重要指标。
      
# 针对浏览器的新打开一个标签页就是一个进程做说明
  - 准确说：为什么只运行了一个浏览器，为什么有多个进程呢？
    原因：
    * 现代浏览器使用的都是多进程架构，打开一个网页时最少需要四个进程，分别是：
      - 浏览器进程，
      - 网络进程，
      - GPU进程，
      - 页面进程（每打开一个页面，都会开启一个），
      - 插件进程（如果浏览器安装插件了，每个插件都是一个进程）。
      
    * 现在的浏览器为了增强稳定性，使用户有个好的上网体验，每打开一个网页就做为独立进程,当浏览器浏览的某个网页由于某种问题不得不退出的时候，不会影响到你同时打开的其它网页，因为其它网页在其它进程内存空间里，不在同空间。否则，如果不管打开多少网页，只有一个进程，那所有进程都在同一内存空间，那一个网页崩溃的时候，会导致你同时打开的所有网页关掉，那用户体验会非常糟糕的。

总结一下： 
  学过物理的都知道最基本的一个概念： 并联和串联。
  从某一角度来说，进程与进程之间就是并联的关系，相互独立，互不影响，就像并联的灯泡你灭了我还在！而某个进程内的线程与线程之间即为串联的关系，互相关联，互相影响，就像串联的灯泡你短路我也灭了。