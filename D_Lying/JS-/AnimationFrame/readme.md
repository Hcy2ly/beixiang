1. 之前 页面实现动画的几种方式
  - 使用css3的相关属性、CSS3的animattion+keyframes;transition;
  - 使用canvas、canvas上作图来实现动画，也可以借助jQuery动画相关的API方便地实现;
  - 使用定时器setTimeout()/setInterval()

2. 使用setTimeout()/setInterval() 定时器函数实现动画的缺点 ： 丢帧
丢帧原因： 但定时器函数的时间间隔小于浏览器刷新频率。
假设定时器时间间隔为10ms，10ms发送一个绘制请求，大概过程： 
  - 1）当第一个绘制请求的到来，并且完成绘制，浏览器刷新一次，页面显示此次绘制的效果。 没有问题。
  - 2）10ms之后，第二个绘制请求到来，并完成绘制，那么以现在大部分浏览器属性频率是16.7ms来算，浏览器刷新是在6.7ms之后，所以页面显示此次绘制的效果是在6.7ms之后。
  - 3）第二次绘制效果展示后，浏览器等待下一次的刷新需要16.7ms，但是3.3ms之后，第三个绘制请求到来并且完成绘制，等到第三次绘制在页面上显示 要等浏览器刷新也就是(16.7-3.3=13.4)ms之后 [BUT10ms之后第四次的绘制请求就会发出，并且完成绘制]
  也就是说，在浏览器第三次刷新的时候，第三次绘制和第四次绘制会同时展示在页面上，第四次的绘制就会覆盖第三次的绘制效果，也就导致丢帧了。


# requestAnimationFrame()
方法从名称看 ，就是专门设计用来完成动画的，并且它是跟随浏览器的刷新频率，如果浏览器的刷新频率是16.7ms，那么它就间隔16.7ms绘制，如果刷新频率是10ms，那么就间隔10ms绘制。
优点：
  - requestAnimationFrame会把每一帧中的所有DOM操作集中起来，再下一次重回或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
  - 隐藏或不可见的元素或者会当前激活选项卡页面，requestAnimationFrame将不会进行重绘或者回流，这当然就意味着更少的cpu，gpu（称显示核心、视觉处理器、显示芯片/ GPU就是图像处理芯片）和内存使用量。
    在老版本的浏览器中，setTimeout() 或者 setInterval() 在非激活的选项卡页面中也会照常进行，据说在当前requestAnimationFrame() 类似的行为，当页面处于闲置状态的时候，如果定时间隔小于1000ms，则停止定时器的执行，不过时间间隔大于或者等于1000ms，定时器依然执行，即使页面最小化或者非激活状态。

和setInterval()类似，返回值也是一个标识，使用cancelAnimationFrame()可以停止动画的执行。


# Polyfill 
Polyfill就是垫片，按发明这个词的人的原话来说，它就是一段这样的代码，让浏览器原生地支持我们期望使用的一些API。说白了就是浏览器兼容 为了兼容一些老的浏览器 ，我们可以写一些代码让浏览器在不支持requestAnimationFrame的情况下使用window.setTimeout()，这是一种回退（fallback）到过去的方法。